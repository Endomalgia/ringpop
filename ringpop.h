/* ringpop - v1.0.0 'Açaí Aggravation' (9-5-2025) - public domain asset packer

	NOT FINISHED AT THE MOMENT!!!!

	Like stb_image please append:
		#define RINGPOP_IMPLEMENTATION
		#include "ringpop.h"
	to a C file. (basically the C code is just in the header :P)

//////////////////////////////// FORMAT /////////////////////////////////
	[Master RING chunk]
		MasterBlockID (4b)  | "RING" (0x52, 0x49, 0x4E, 0x47)
		FileSize	  (4b)  | Size of the file in bytes (unsigned long int)
		VersionString (16b) | Condensed version string (null terminated)
	[Data array chunk]
		DABlockID     (4b)  | "dac␣" (0x64, 0x61, 0x63, 0x20)
		NAssets		  (2b)	| Number of assets (unsigned short int)
		DataArrat     (26nb)| Array of asset file information
								AssetType (2b)	| Asset type
								AssetID   (16b) | Name of asset (null terminated)
								AssetLen  (4b)	| Length of the asset in bytes
								AssetLoc  (4b)	| Location of the asset in the file
	[Data chunk]
		DataBlockID	  (4b)	| "data" (0x52, 0x49, 0x4E, 0x47)
		AssetData	  (xnb)	| File data separated by something? idk yet tbh
								DataSep   (16b) | "\0EOF SEPARATOR!\0" is 
													pasted between files for
													no real reason.

//////////////////////////// HEADER  OUTPUT /////////////////////////////
	\/\* This file was automatically generated by ringpop [version string] on [date] \*\/

	const char** RINGPOP_ARRAY = {RING_[NAMEw/o.ri]_FILEPATH, ...}

	// For each ring file
	#define RING_[NAMEw/o.ri]_FILEPATH	[enc->filepath]
	#define RING_[NAMEw/o.ri]_NASSETS		[enc->na]
	#define RING_[NAMEw/o.ri]_INDEX			[index of RIng]

	// For each asset
	const RIasset [ASSET NAME] = {asset.name, asset.length, asset.offset, asset.type, RING_[NAMEw/o.ri]_INDEX}; 

	...
	...
	
where

	typedef struct {
		char* name;
		long length;
		long offset;
		int type;
		int rp_index; // Index of the ring file the asset is contained within
	} RIasset;

*/

#ifndef RINGPOP_INCLUDE_H
#define RINGPOP_INCLUDE_H
/*
//////////////////////////// DOCUMENTATION //////////////////////////////

	Might put something here later, for now...... perish

*/

/* includes */
#include <portaudio.h>
#include <sndfile.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>
#include <string.h>
#include <errno.h>
#include <math.h>

/* 'globals' */

static const char FMT_MASTERBLOCKID[4]						= {0x52, 0x49, 0x4E, 0x47};	// 4b RING
static const char FMT_DATAARRAYBLOCKID[4]				  	= {0x64, 0x61, 0x63, 0x20};	// 4b dac␣
static const char FMT_DATABLOCKID[4]						= {0x64, 0x61, 0x74, 0x61};	// 4b data
static const char FMT_VERSIONSTRING[16]						= "v1.0.0 Açaí\0\0\0";   // 16b Is a /0 automatically added when strings are defined like this?

static const char FMT_FILEDIVIDER[16]						= "\0EOF SEPARATOR!\0";		// 16b

/* macros */

#define SIZEOF_READBUFFER	 		64
#define FMT_SIZEOF_MASTERBLOCK		24
#define FMT_SIZEOF_DACHEADER		6
#define FMT_SIZEOF_DATAHEADER		4
#define FMT_SIZEOF_DACASSET			26
#define FMT_SIZEOF_FILEDIVIDER		16

/* types */

enum RIASSET_TYPE {
	UNKNOWN,
	LIBSNDFILE,
	STBIMAGE
};

typedef struct {
	int		asset_fptr;
	int		encoder_fptr;
	char*	name;
	long	length;
	long 	offset;
	int 	type;
} RIASSET;

typedef struct {
	int   				fptr;
	unsigned long  int 	length;
	unsigned short int 	na;
	RIASSET*			assets;
	char* 				filename;
} RIEncoder;

/* functions */

/* RI Encoder Creation */
RIEncoder* wriStartEncoder(char* ri_filepath);					// Creating new *.ri
RIEncoder* wriOpenEncoder(char* ri_filepath, int access_mode);	// Writing to existing *.ri (O_RDONLY, O_WRONLY, O_RDWR)
void wriCloseEncoder(RIEncoder* enc);

/* RI Writing */
void wriWriteMaster(RIEncoder* enc);
void wriWriteDAC(RIEncoder* enc);
void wriAppendAssets(RIEncoder* enc, RIASSET* assets, int n);
//void wriRemoveAssetbyIndex(RIEncoder* enc, int index); // I'm not going to do this until I have to use it which will be never. Just make another one lol :3.

/* RI Reading */
void wriReadMaster(RIEncoder* enc);
void wriReadDAC(RIEncoder* enc);
void wriListAssets(RIEncoder* enc);

/* Asset Access */
int wriAssetGetFD(RIEncoder* enc, char* name);
int wriAssetGetFDbyIndex(RIEncoder* enc, int index);

/* Asset Array */
void wriOpenAssets(char** fp_array, RIASSET* ri_array, int n);

/* Assorted */
void wriWriteToHeader(RIEncoder* enc);

/* Callbacks */
int _RIASSET_LENGTH_CALLBACK(RIASSET* asset);
int _RIASSET_SEEK_CALLBACK(int offset, int whence, RIASSET* asset);
int _RIASSET_READ_CALLBACK(void* ptr, int count, RIASSET* asset);
int _RIASSET_WRITE_CALLBACK(const void* ptr, int count, RIASSET* asset);
int _RIASSET_TELL_CALLBACK(RIASSET* asset);

#endif
#ifdef RINGPOP_IMPLEMENTATION
 
/*////////////////////////// IMPLEMENTATION /////////////////////////////
	
	C code starts here

*/

#define MIN(i, j) (((i) < (j)) ? (i) : (j))
#define MAX(i, j) (((i) > (j)) ? (i) : (j))

// https://stackoverflow.com/questions/109023/count-the-number-of-set-bits-in-a-32-bit-integer
int nSetBits(int i) {
	i = i - ((i >> 1) & 0x55555555);        		// add pairs of bits
    i = (i & 0x33333333) + ((i >> 2) & 0x33333333); // quads
    i = (i + (i >> 4)) & 0x0F0F0F0F;        		// groups of 8
    i *= 0x01010101;                        		// horizontal sum of bytes
    return  i >> 24;  
}

int nUsedBytes(int i) {
	if (i<=0)
		return 0;
	int o = 1;
	int t = i;
	while(t >>= 8)
		o++;
	return o;
}

// hex string to integer (with leading zeros and fixed length)
int xtoi(char* xbuf, int nelem) {
	if (nelem == 0) [[unlikely]]
		return 0;
	unsigned int o = 0;
	for (int i=0; i<nelem; i++) {
		o+=((unsigned char)xbuf[i] << (8*i));
	}
	return (int)o;
}

long int flen(int fd) {
	struct stat info;
	fstat(fd, &info);
	return (long)info.st_size;
}

RIEncoder* wriStartEncoder(char* ri_filepath) {
	RIEncoder* enc;

	// Check if the file exists
	if (access(ri_filepath, F_OK) == 0) {
		printf("[E] wriStartEncoder: File already exists [%s]\n\t%s\n", ri_filepath, strerror(errno));
		exit(0);
	}

	enc = malloc(sizeof(RIEncoder));
	enc->filename = ri_filepath;
	enc->assets = malloc(0);
	enc->fptr = open(ri_filepath, O_CREAT | O_RDWR, S_IRUSR | S_IWUSR);
	enc->na = enc->length = 0;
	if (enc->fptr < 0) {
		printf("[E] wriStartEncoder: Unable to open file [%s]\n\t%s\n", ri_filepath, strerror(errno));
		exit(0);
	}

	// Write out empty data array chunk
	wriWriteDAC(enc);

	// Write the data header label thingie
	lseek(enc->fptr, FMT_SIZEOF_MASTERBLOCK + FMT_SIZEOF_DACHEADER + FMT_SIZEOF_DACASSET*enc->na, SEEK_SET);
	write(enc->fptr, FMT_DATABLOCKID, FMT_SIZEOF_DATAHEADER);

	// Write out the master ring chunk
	wriWriteMaster(enc);

	return enc;
}

RIEncoder* wriOpenEncoder(char* ri_filepath, int access_mode) {
	RIEncoder* enc;

	// Check if the file doesn't exist
	if (access(ri_filepath, F_OK) != 0) {
		printf("[E] wriOpenEncoder: File does not exist [%s]\n\t%s\n", ri_filepath, strerror(errno));
		exit(0);
	}

	enc = malloc(sizeof(RIEncoder));
	enc->filename = ri_filepath;
	enc->assets = malloc(0);
	enc->fptr = open(ri_filepath, access_mode, S_IRUSR | S_IWUSR);
	enc->na = enc->length = 0;
	if (enc->fptr < 0) {
		printf("[E] wriOpenEncoder: Unable to open file [%s]\n\t%s\n", ri_filepath, strerror(errno));
		exit(0);
	}

	wriReadMaster(enc);
	wriReadDAC(enc);

	return enc;
}

void wriCloseEncoder(RIEncoder* enc) {
	for (int i=0; i<enc->na; i++) {
		close(enc->assets[i].asset_fptr);
		free(enc->assets[i].name);
	}
	free(enc->assets);
	close(enc->fptr);
}

void wriWriteMaster(RIEncoder* enc) {
	enc->length = (long)MAX(flen(enc->fptr), FMT_SIZEOF_MASTERBLOCK);
	char buf[FMT_SIZEOF_MASTERBLOCK];

	memset(buf, 0, FMT_SIZEOF_MASTERBLOCK);
	memcpy(buf, 							FMT_MASTERBLOCKID, 	4);
	memcpy(buf+4, 							&(enc->length), 	4); 
	memcpy(buf+8, 							FMT_VERSIONSTRING, 	16);

	lseek(enc->fptr, 0, SEEK_SET);
	write(enc->fptr, buf,	FMT_SIZEOF_MASTERBLOCK);
}

void wriWriteDAC(RIEncoder* enc) {
	int dac_size = 6 + (FMT_SIZEOF_DACASSET * enc->na);
	char* buf = malloc(dac_size);

	memset(buf, 0, dac_size);

	memcpy(buf, 									FMT_DATAARRAYBLOCKID, 				4);
	memcpy(buf+4, 									&(enc->na), 						2);
	enc->length = FMT_SIZEOF_MASTERBLOCK + FMT_SIZEOF_DACHEADER + FMT_SIZEOF_DACASSET*enc->na + FMT_SIZEOF_DATAHEADER;
	for (int i=0;i<enc->na;i++) {
		int l = 6 + (FMT_SIZEOF_DACASSET * i);
		enc->assets[i].offset = enc->length;

		memcpy(buf+l,										&(enc->assets[i].type), 	2);
		memcpy(buf+l+2,										enc->assets[i].name, 		MIN(16, strlen(enc->assets[i].name))); // Remove ext and null
		memcpy(buf+l+18,									&(enc->assets[i].length), 	4);
		memcpy(buf+l+22,									&(enc->assets[i].offset), 	4);
		
		enc->length += enc->assets[i].length + FMT_SIZEOF_FILEDIVIDER;
	}

	lseek(enc->fptr, FMT_SIZEOF_MASTERBLOCK, SEEK_SET);
	write(enc->fptr, buf,	dac_size);
	free(buf);
}

void wriAppendAssets(RIEncoder* enc, RIASSET* assets, int n) {
	char content_buf[SIZEOF_READBUFFER];
	char size_buf[4];
	struct stat info;

	long int eof_data_offset = FMT_SIZEOF_DACASSET*n;
	long int new_eof = eof_data_offset + enc->length;
	enc->na += n;

	// Append each asset to the encoder
	enc->assets = realloc(enc->assets, enc->na * sizeof(RIASSET));
	for (int a=0; a<n; a++) {
		assets[a].encoder_fptr = enc->fptr;
		enc->assets[a+enc->na-n] = assets[a];
	}

	// Offset the current data in chunks of size SIZEOF_READBUFFER
	lseek(enc->fptr, 0, SEEK_END); // Number of blocks does not include any remainder
	long int data_start = FMT_SIZEOF_MASTERBLOCK + FMT_SIZEOF_DACHEADER + FMT_SIZEOF_DACASSET*(enc->na-n) + FMT_SIZEOF_DATAHEADER;
	long int data_len = enc->length - data_start;
	int n_blocks = (int)ceil((double)data_len / (double)SIZEOF_READBUFFER);
	for (int b=1; b<n_blocks+1;b++) {
		lseek(enc->fptr, data_start + (n_blocks-b)*SIZEOF_READBUFFER, SEEK_SET);
		read(enc->fptr, content_buf, SIZEOF_READBUFFER);
		lseek(enc->fptr, data_start + (n_blocks-b)*SIZEOF_READBUFFER + eof_data_offset, SEEK_SET);
		write(enc->fptr, content_buf, SIZEOF_READBUFFER);
	}

	// Write to the dac
	wriWriteDAC(enc);

	// Write in the new data
	lseek(enc->fptr, new_eof, SEEK_SET);
	for (int c=enc->na-n; c<enc->na; c++) {
		while(read(enc->assets[c].asset_fptr, content_buf, SIZEOF_READBUFFER)) {
			write(enc->fptr, content_buf, SIZEOF_READBUFFER);
		}
		lseek(enc->fptr, new_eof+enc->assets[c].length, SEEK_SET);
		write(enc->fptr, FMT_FILEDIVIDER, FMT_SIZEOF_FILEDIVIDER);
		new_eof += enc->assets[c].length + FMT_SIZEOF_FILEDIVIDER; // Could also get the file pointer at the end of this loop with ftell()
	}
	ftruncate(enc->fptr, new_eof); // Prevent any 'remainders' (shorter last blocks) from becoming an issue XP

	// Rewrite the data header label thingie
	lseek(enc->fptr, FMT_SIZEOF_MASTERBLOCK + FMT_SIZEOF_DACHEADER + FMT_SIZEOF_DACASSET*enc->na, SEEK_SET);
	write(enc->fptr, FMT_DATABLOCKID, FMT_SIZEOF_DATAHEADER);

	// Write master header (last as it contains the file size);
	wriWriteMaster(enc);
}

void wriReadMaster(RIEncoder* enc) {
	char buf[4];
	lseek(enc->fptr, 4, SEEK_SET); // countof(FMT_MASTERBLOCKID)?
	read(enc->fptr, buf, 4);
	enc->length = xtoi(buf, 4);
	if (enc->length != flen(enc->fptr)) {
		printf("[E] wriReadMaster: file appears corrupted (%ld (read length) != %ld (actual length) %d)\n\t%s\n", enc->length, flen(enc->fptr), enc->fptr, strerror(errno));
		exit(0);
	}
}

void wriReadDAC(RIEncoder* enc) {
	char data_buf[26];

	lseek(enc->fptr, FMT_SIZEOF_MASTERBLOCK + 4, SEEK_SET);
	read(enc->fptr, data_buf, 2);
	enc->na = xtoi(data_buf, 2);
	enc->assets = realloc(enc->assets, enc->na * sizeof(RIASSET));
	for (int i=0; i<enc->na; i++) {
		read(enc->fptr, data_buf, 26); // Read entire asset into buffer

		enc->assets[i].asset_fptr = -1; // Not relevent during a read, do manually.
		enc->assets[i].type = xtoi(data_buf,2);

		enc->assets[i].name = malloc(16); // FIND A WAY AROUND THIS!!!!
		memcpy(enc->assets[i].name, data_buf+2, 16);

		enc->assets[i].length = xtoi(data_buf+18,4);
		enc->assets[i].offset = xtoi(data_buf+22,4);
	}
}

void wriListAssets(RIEncoder* enc) {
	char version_buf[16];
	lseek(enc->fptr, 8, SEEK_SET);
	read(enc->fptr, version_buf, 16);
	printf("VERSION: %.*s\t - %s (%ldb) - \t NUMBER OF ASSETS: %d\n", 16, version_buf, enc->filename, enc->length, enc->na);
	for (int i=0; i<enc->na; i++) {
		printf("\tASSET [%d] - \"%.*s\"\n\t\tTYPE: %d\n\t\tLENGTH: %ld\n\t\tPOSITION IN FILE: %ld\n", i, 16, enc->assets[i].name, enc->assets[i].type, enc->assets[i].length, enc->assets[i].offset);
	}
}

int wriAssetGetFD(RIEncoder* enc, char* name) {
	wriReadDAC(enc);
	for (int i=0; i<enc->na; i++) {
		if (strcmp(name, enc->assets[i].name) == 0) {
			lseek(enc->fptr, enc->assets[i].offset, SEEK_SET);
			return enc->fptr;
		}
	}
	printf("[E] wriAssetGetFD: Unable to locate asset [%s]\n", name);
	exit(0);
}

int wriAssetGetFDbyIndex(RIEncoder* enc, int index) {
	if (index >= enc->na) {
		printf("[E] wriAssetGetFDbyIndex: Index out of range [%d out of %d]\n", index,enc->na);
		exit(0);
	}
	lseek(enc->fptr, enc->assets[index].offset, SEEK_SET);
	return enc->fptr;
}

void wriOpenAssets(char** fp_array, RIASSET* ri_array, int n) {
	for (int i=0;i<n;i++) {
		if (access(fp_array[i], F_OK) != 0) {
			printf("[E] wriOpenAssets: Unable to open asset [%s]\n\t%s\n", fp_array[i], strerror(errno));
			exit(0);
		}
		ri_array[i].asset_fptr 	= open(fp_array[i], O_RDONLY, S_IRUSR);
		ri_array[i].encoder_fptr = -1;
		ri_array[i].length 		= flen(ri_array[i].asset_fptr);

		ri_array[i].name = malloc(16);
		memcpy(ri_array[i].name, fp_array[i], 16);
		//ri_array[i].name	= fp_array[i];
		ri_array[i].offset 	= -1;
		ri_array[i].type 	= 0; // Switch over extensions eventually
	}
}

void wriWriteToHeader(RIEncoder* enc) {
	
}

int _RIASSET_LENGTH_CALLBACK(RIASSET* asset) {
	return asset->length;
}

int _RIASSET_SEEK_CALLBACK(int offset, int whence, RIASSET* asset) {
	int c_pos = lseek(asset->encoder_fptr, 0, SEEK_CUR) - asset->offset;
	printf("Seeking to (%db) in virtual file, actually seeking to (%db)\n", c_pos + offset, c_pos + offset + asset->offset);
	return lseek(asset->encoder_fptr, offset + asset->offset, whence);
}

int _RIASSET_READ_CALLBACK(void* ptr, int count, RIASSET* asset) {
	printf("A read is occuring (%db) using \"%.*s\"!\n",count,16,asset->name);
	printf("File position at start of read is (%db)\n",lseek(asset->encoder_fptr, 0, SEEK_CUR));
	return read(asset->encoder_fptr, ptr, count);
}

int _RIASSET_WRITE_CALLBACK(const void* ptr, int count, RIASSET* asset) {
	//return read(assets->encoder_fptr, ptr, count);
	return 0; // Don't let this happen ideally
}

int _RIASSET_TELL_CALLBACK(RIASSET* asset) {
	return lseek(asset->encoder_fptr, 0, SEEK_CUR) - asset->offset;
}

#endif
